# POE方法校准代码说明

## 一、POE方法简介

### 1.1 什么是POE？

**POE（Product of Exponentials，指数积）** 是一种基于螺旋理论（Screw Theory）的机器人运动学表示方法。

**核心公式：**
```
T(θ) = exp([ξ₁]θ₁) × exp([ξ₂]θ₂) × ... × exp([ξₙ]θₙ) × M(0)
```

其中：
- `ξᵢ`：第i个关节的螺旋轴（screw axis），6维向量 `[ω, v]`
- `θᵢ`：第i个关节的角度
- `M(0)`：零位时的末端位姿

---

## 二、POE vs DH方法对比

### 2.1 参数对比

| 方法 | 每个关节参数 | 总参数数（n关节） |
|------|------------|------------------|
| DH方法 | 4个 (a, d, α, θ) | 4n + 6（相机参数） |
| POE方法 | 6个 (ω₃, v₃) + 6（零位位姿） | 6n + 6 + 6 |

### 2.2 优势对比

**POE方法的优势：**
- ✅ 不需要中间坐标系
- ✅ 参数更直观（螺旋轴直接表示运动方向）
- ✅ 雅可比计算更简单（使用Adjoint变换）
- ✅ 更适合某些特殊结构的机器人

**DH方法的优势：**
- ✅ 参数更少（每个关节4个）
- ✅ 更成熟，应用更广泛
- ✅ 参数有明确的物理意义

---

## 三、代码结构

### 3.1 主要类：`POECalibration`

**关键方法：**

1. **`screw_to_se3()`** - 螺旋坐标转SE(3)变换
   ```python
   exp([ξ]θ) = SE3变换矩阵
   ```

2. **`forward_kinematics()`** - POE正向运动学
   ```python
   T = exp(ξ₁θ₁) × exp(ξ₂θ₂) × ... × exp(ξₙθₙ) × M(0)
   ```

3. **`compute_jacobian()`** - POE雅可比计算
   ```python
   J_i = Ad_{T_i}(ξ_i)
   ```

4. **`_adjoint()`** - Adjoint变换
   ```python
   Ad_T = [R    0]
          [p^R R]
   ```

---

## 四、关键实现

### 4.1 螺旋坐标转SE(3)

**Rodrigues公式：**
```python
R = I + sin(θ) * ω^ + (1 - cos(θ)) * ω^²
t = (I - R) * (ω × v) / ||ω||² + ω * ω^T * v * θ / ||ω||
```

### 4.2 正向运动学

```python
T_base_end = M0
for i, (omega, v) in enumerate(screw_axes):
    exp_xi_theta = screw_to_se3(omega, v, q[i])
    T_base_end = T_base_end * exp_xi_theta
```

### 4.3 雅可比计算

**POE方法的雅可比：**
```python
J_i = Ad_{T_i}(ξ_i)
```

其中 `Ad_T` 是Adjoint变换，将螺旋坐标从局部坐标系转换到全局坐标系。

---

## 五、使用方法

### 5.1 运行代码

```bash
conda activate dh_calibration
python3 poe_calibration.py
```

### 5.2 参数设置

**螺旋轴定义：**
```python
# 旋转关节（绕z轴）
omega = [0, 0, 1]  # 旋转轴方向
v = [-ω × p]       # 线速度（轴上一点p）

# 示例：2关节机器人
screw_axes = [
    ([0, 0, 1], [0, 0, 0]),      # 关节1：绕z轴旋转
    ([0, 0, 1], [0, -0.3, 0])    # 关节2：绕z轴旋转，轴上一点在y=-0.3
]
```

**零位位姿：**
```python
# 所有关节角度为0时的末端位姿
M0 = SE3.Rt(R0, t0)
```

---

## 六、DH到POE转换

### 6.1 辅助函数：`dh_to_poe()`

代码中提供了从DH参数转换为POE参数的函数：

```python
screw_axes, M0 = dh_to_poe(dh_params)
```

**转换原理：**
1. 计算零位时的末端位姿（所有θ=0）
2. 计算每个关节的螺旋轴：
   - ω：旋转轴方向（z轴方向）
   - v：-ω × p（p是轴上一点）

---

## 七、运行结果

### 7.1 典型输出

```
开始校准（POE方法）...
初始参数误差: 0.017
迭代 1: 位置误差 = 0.080mm
迭代 2: 位置误差 = 0.091mm
...
位置误差已稳定，停止于第 X 次迭代

参数误差:
  关节 1: ω误差: 0.015, v误差: 0.015
  关节 2: ω误差: 0.008, v误差: 0.016

位置误差: 0.01-0.04mm
```

### 7.2 收敛曲线

代码会生成 `poe_calibration_convergence.png`，显示误差收敛过程。

---

## 八、注意事项

### 8.1 参数化

- POE方法参数更多（每个关节6个）
- 需要约束螺旋轴为单位向量（或使用其他参数化）
- 当前实现简化处理，可能需要进一步优化

### 8.2 数值稳定性

- 步长需要更小（当前设置为0.01）
- 正则化参数可能需要调整
- 某些参数可能不可识别

### 8.3 初始值

- 初始值不能离真实值太远
- 建议从DH参数转换得到初始值
- 零位位姿的初始值很重要

---

## 九、改进方向

### 9.1 参数化优化

- 使用球坐标参数化旋转轴（2个参数而不是3个）
- 添加单位向量约束
- 使用更合适的参数化方式

### 9.2 雅可比改进

- 更精确的数值微分
- 更好的Adjoint变换计算
- 处理奇异情况

### 9.3 优化算法

- 使用Levenberg-Marquardt方法
- 自适应步长
- 更好的收敛判断

---

## 十、总结

### 10.1 POE方法特点

- **优点**：不需要中间坐标系，参数直观，雅可比简单
- **缺点**：参数更多，需要更多计算

### 10.2 适用场景

- 并联机器人
- 冗余机器人
- 某些特殊结构的机器人
- 需要避免中间坐标系的情况

### 10.3 代码状态

- ✅ 基本功能已实现
- ✅ 可以运行并收敛
- ⚠️ 精度可能需要进一步优化
- ⚠️ 参数化方式可以改进

---

## 十一、参考

- Modern Robotics: Mechanics, Planning, and Control (Lynch & Park)
- Springer Handbook of Robotics Chapter 1.8
- Screw Theory in Robotics

