用一个简单的2关节机器人例子说明：

## 具体例子：2关节机器人校准

### 一、场景设置

假设：
- 2关节机器人（2个旋转关节）
- 3D相机固定在环境中
- 棋盘格固定在末端执行器上

### 二、坐标系定义

```
坐标系 -1：相机坐标系（固定）
坐标系 0：中间坐标系（连接相机和机器人）
坐标系 1：机器人基坐标系（第1个关节）
坐标系 2：第2个关节坐标系
坐标系 3：末端坐标系
坐标系 4：棋盘格坐标系（测量点）
```

### 三、具体数值示例

#### **假设当前参数估计值（第k次迭代）：**

**相机位置参数：**
- `d_0 = 100mm`, `θ_0 = 30°`
- `a_1 = 200mm`, `d_1 = 50mm`, `α_1 = 0°`, `θ_1 = 0°`

**机器人DH参数：**
- 第1关节：`a_2 = 300mm`, `d_2 = 0mm`, `α_2 = 0°`, `θ_2 = 0°`
- 第2关节：`a_3 = 250mm`, `d_3 = 0mm`, `α_3 = 0°`, `θ_3 = 0°`

**末端到棋盘格参数：**
- `a_4 = 100mm`, `d_3 = 0mm`, `θ_3 = 0°`

#### **假设当前位姿（位姿l）：**
- 关节角度：`q_1 = 45°`, `q_2 = 30°`

---

### 四、测量值（从3D相机得到）

#### **步骤1：3D相机拍摄**

```
RGB图像 + 深度图
```

#### **步骤2：检测棋盘格角点**

```
检测到9个角点，像素坐标：
角点1: (u_1=320, v_1=240)
角点2: (u_2=380, v_2=240)
...
角点9: (u_9=500, v_9=320)
```

#### **步骤3：读取深度**

```
从深度图读取每个角点的深度：
角点1: Z_1 = 800mm
角点2: Z_2 = 805mm
...
角点9: Z_9 = 810mm
```

#### **步骤4：计算3D坐标**

假设相机内参：`f = 500`, `u_c = 320`, `v_c = 240`

```
角点1的3D坐标：
X_1 = (320 - 320) × 800 / 500 = 0mm
Y_1 = (240 - 240) × 800 / 500 = 0mm
Z_1 = 800mm
P_1^C = [0, 0, 800]^T

角点2的3D坐标：
X_2 = (380 - 320) × 805 / 500 = 96.6mm
Y_2 = (240 - 240) × 805 / 500 = 0mm
Z_2 = 805mm
P_2^C = [96.6, 0, 805]^T

...（其他角点类似）
```

#### **步骤5：拟合坐标系**

已知棋盘格上角点的局部坐标（棋盘格坐标系）：
```
P_1^G = [0, 0, 0]^T
P_2^G = [30, 0, 0]^T  （假设方格尺寸30mm）
...
```

通过最小二乘拟合，得到棋盘格在相机坐标系中的位姿：
```
测量值：
-1p_4 (measured) = [100, 200, 800]^T  mm
-1R_4 (measured) = [1    0    0  ]
                   [0  0.866 0.5 ]
                   [0  -0.5 0.866]  （假设旋转）
```

---

### 五、理论值（通过运动学模型计算）

#### **步骤1：计算各个变换矩阵**

**1.1 相机到中间坐标系：`-1T_0`**

```
-1T_0 = Rot(x, 0°) × Trans(x, 0) × Trans(z, 100) × Rot(z, 30°)

计算：
-1T_0 = [0.866  -0.5   0    0   ]
        [0.5    0.866  0    0   ]
        [0      0      1    100 ]
        [0      0      0    1   ]
```

**1.2 中间坐标系到基坐标系：`0T_1`**

```
0T_1 = Rot(x, 0°) × Trans(x, 200) × Trans(z, 50) × Rot(z, 0° + 45°)

计算：
0T_1 = [0.707  -0.707  0    141.4]
       [0.707   0.707  0    141.4]
       [0       0      1    50   ]
       [0       0      0    1    ]
```

**1.3 第1关节到第2关节：`1T_2`**

```
1T_2 = Rot(x, 0°) × Trans(x, 300) × Trans(z, 0) × Rot(z, 0° + 30°)

计算：
1T_2 = [0.866  -0.5   0    259.8]
       [0.5    0.866  0    150  ]
       [0      0      1    0    ]
       [0      0      0    1    ]
```

**1.4 第2关节到末端：`2T_3`**

```
2T_3 = Rot(x, 0°) × Trans(x, 250) × Trans(z, 0) × Rot(z, 0°)

计算：
2T_3 = [1  0  0  250]
       [0  1  0  0  ]
       [0  0  1  0  ]
       [0  0  0  1  ]
```

**1.5 末端到棋盘格：`3T_4`**

```
3T_4 = Rot(x, 0°) × Trans(x, 100) × Trans(z, 0) × Rot(z, 0°)

计算：
3T_4 = [1  0  0  100]
       [0  1  0  0  ]
       [0  0  1  0  ]
       [0  0  0  1  ]
```

#### **步骤2：计算完整变换链**

```
-1T_4 = -1T_0 × 0T_1 × 1T_2 × 2T_3 × 3T_4
```

**矩阵连乘：**
```
-1T_4 = [0.866  -0.5   0    0   ]   [0.707  -0.707  0    141.4]   [0.866  -0.5   0    259.8]   [1  0  0  250]   [1  0  0  100]
        [0.5    0.866  0    0   ] × [0.707   0.707  0    141.4] × [0.5    0.866  0    150  ] × [0  1  0  0  ] × [0  1  0  0  ]
        [0      0      1    100 ]   [0       0      1    50   ]   [0      0      1    0    ]   [0  0  1  0  ]   [0  0  1  0  ]
        [0      0      0    1   ]   [0       0      0    1    ]   [0      0      0    1    ]   [0  0  0  1  ]   [0  0  0  1  ]
```

**逐步计算：**

**第一步：`-1T_0 × 0T_1`**
```
= [0.866  -0.5   0    0   ]   [0.707  -0.707  0    141.4]
  [0.5    0.866  0    0   ] × [0.707   0.707  0    141.4]
  [0      0      1    100 ]   [0       0      1    50   ]
  [0      0      0    1   ]   [0       0      0    1    ]

= [0.258  -0.966  0    70.7 ]
  [0.966   0.258  0    141.4]
  [0       0      1    150  ]
  [0       0      0    1    ]
```

**继续计算...（简化，假设最终结果）**

**最终结果：**
```
-1T_4 = [0.866  -0.5   0    450]
        [0.5    0.866  0    300]
        [0      0      1    850]
        [0      0      0    1  ]
```

#### **步骤3：提取位置**

```
理论值：
-1p_4 (computed) = [450, 300, 850]^T  mm
-1R_4 (computed) = [0.866  -0.5   0  ]
                   [0.5    0.866  0  ]
                   [0      0      1  ]
```

---

### 六、计算误差

#### **位置误差：**

```
Δp = -1p_4 (measured) - -1p_4 (computed)
   = [100, 200, 800]^T - [450, 300, 850]^T
   = [-350, -100, -50]^T  mm
```

#### **方向误差：**

```
ΔR = -1R_4 (measured) × [-1R_4 (computed)]^T
   = [1    0    0  ]   [0.866   0.5    0]
     [0  0.866 0.5 ] × [-0.5   0.866  0]
     [0  -0.5 0.866]   [0      0      1]

   = [0.866   0.5    0]
     [0.433 0.75  0.5]
     [-0.25 0.433 0.866]

Δρ ≈ [0.433 - 0.5, 0.25 - 0, 0.5 - 0.433]^T / 2
    = [-0.0335, 0.125, 0.0335]^T  rad
```

#### **组合误差：**

```
Δy = [Δp]
     [Δρ]
   = [-350]
     [-100]
     [-50 ]
     [-0.0335]
     [0.125]
     [0.0335]
```

---

### 七、最小二乘优化

#### **对所有位姿（假设有20个位姿）：**

```
Δy = [Δy^1]
     [Δy^2]
     [... ]
     [Δy^20]

J = [J^1]
    [J^2]
    [... ]
    [J^20]
```

#### **求解参数修正量：**

```
Δφ = (J^T × J)^{-1} × J^T × Δy
```

**假设结果：**
```
Δφ = [Δd_0 = 5mm]
     [Δθ_0 = 2°]
     [Δa_1 = -10mm]
     [Δd_1 = 3mm]
     [Δα_1 = 0.5°]
     [Δθ_1 = -1°]
     [Δa_2 = 8mm]
     ...
```

#### **更新参数：**

```
φ^{k+1} = φ^k + Δφ

新的参数：
d_0 = 100 + 5 = 105mm
θ_0 = 30° + 2° = 32°
a_1 = 200 - 10 = 190mm
...
```

---

### 八、迭代过程

#### **第1次迭代（k=0）：**
- 使用初始参数估计
- 计算理论值：`[450, 300, 850]^T`
- 测量值：`[100, 200, 800]^T`
- 误差：`[-350, -100, -50]^T`
- 更新参数

#### **第2次迭代（k=1）：**
- 使用更新后的参数
- 重新计算理论值（应该更接近测量值）
- 计算新的误差（应该更小）
- 继续更新参数

#### **迭代直到收敛：**
- 误差足够小：`||Δy|| < 阈值`
- 或参数变化足够小：`||Δφ|| < 阈值`

---

### 九、关键理解

#### **整个流程：**

1. **测量值**：从3D相机测量棋盘格位置 `[100, 200, 800]^T`
2. **理论值**：用当前参数和关节角度计算 `[450, 300, 850]^T`
3. **误差**：测量值 - 理论值 = `[-350, -100, -50]^T`
4. **优化**：调整参数，使理论值接近测量值
5. **迭代**：重复直到收敛

#### **为什么理论值会不同？**

- 如果参数准确，理论值应该接近测量值
- 如果参数不准确（如 `a_1` 估计错误），理论值会偏离测量值
- 通过最小二乘法调整参数，使理论值逐渐接近测量值

这个例子是否更清楚了？